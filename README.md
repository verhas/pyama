# Pyama

Pyama is a command line automated editor that performs some of the tasks that are
otherwise performed manually using some editors. It can be used to modify text
source files in any programming languages inserting or updating boilerplate code.

Modifying the source code programmatically is usually not a good practice. Don't do
that if it is possible. Pyama is a practical tool to amend the code editing workflow.
If you have to generate code, it means that your development process is not optimal.
The reason can be the insufficiency of some of the tools. For example, you generate
getters and setters into the source code, because Java does not
generate automatically the setters and getters during compilation time. But getters and
setters are generated by any editors, that is simple. Unless you forget to regenerate when you
change the code.

## Sample Problems Needing Pyama

### Creating setters, getters, constructor, hashCode, toString, equals...

These are code fragments that are generated most of the time. These are so general problems and 
they are needed to be generated for Java programs that even the IDEs support the generation of
these methods.

The issue using the IDE is that you can forget to update your class after you modified the fields.

Pyama has a built-in Java handler that can generate these and more and even if you forgot to
regenerate one of the hashCode or toString of some of the classes you modified Pyama will
regenerate them all when you run it. If you forget to run Pyama altogether that is a problem
Nevertheless, it is much easier to run a command line tool once than remembering what classes
you changed and ask the IDE one by one to regenerate the code.

In addition to the code that IDEs can generate Pyama can also generate a nested builder class,
and we plan to add arbitrary code generation without Python coding via templates.

### Converting object to Map and back

I faced other issues that are almost as simple as generating setters and getters, but being
specific they are not supported by the IDE. I had many Java classes that I needed to
convert to `Map` and from `Map` to object. The general solution would have been to 
create a reflection tool that reads the fields of the object and generates the `Map`
and another that reads the values from the `Map` and wrote the fields of the object.
For some technical reasons (some of which could have been coped with though) using
reflection was not an option. We ended up hand-coding the back and forth conversions.
(Also know that I simplified the issue, the real-life problem was more complex.) 


### Include code snippets to documentation

Another issue I faced during my practice is that most of the markup languages do not
allow to include a snippet from other source files. For example, using markdown
you can have some sample code like the following:

[//]: # (USE SNIPPET run.py/run_py)
```python
from pyama.configuration import Configuration
from pyama.snippet import MdSnippetWriter, SnippetReader, SnippetMacro
from pyama.processor import Processor

MD = Configuration().file(".*\\.md$").handler(MdSnippetWriter(),SnippetReader())
PY = Configuration().file(".*\\.py$").handler(SnippetReader())
JAVA = Configuration().file(".*\\.java$").handler(SnippetReader(),SnippetMacro())
configs = [MD, PY, JAVA]

Processor(configs, "**/*.*").process()
``` 

I wanted to have these code fragments copied from the source code, usually from
unit test files. Whenever the unit test changed it had to be copied to the documentation.

The first solution was to use some existing macro tool that processed some mainly
markdown file and generated the markdown. Then I faced that the editors that show the
markdown WYSIWYG could not cope with the file that still needed preprocessing.

What I actually wanted was to automate the copy paste from the unit test code to the
documentation and that is what Pyama does.

## What is Pyama

Pyama reads a set of files, extracts information from these files and then selects some
of the files and overwrites some part of those files. It automates the modification of
the source files that are kind of redundant. The way it works general and extendable,
configurable. To use it you do not need to understand Python, though it does not hurt.

Typically you will install Pyama into your development environment and you create a `run.py`
file in your development root directory. You can name it any way you want btw. It will
be a python source file. The actual `run.py` of this project you can see above.

Yes, it was copied into this md file using Pyama. This little program declares the
configuration that, in this case, says we are using markdown and python source files and
we define two segment handlers. We will discuss them later. They need a bit of python
knowledge but Pyama is designed so that it is extremely easy to create segment handlers.

After the declaration of the file types and how we want to handle them, we invoke the
Pyama processor and generally that is it. Pyama reads all the files that match `**/*.*`
and calls the handlers to do their work. `SnippetReader` is written to read the
code fragments from the python source files and `MdSnippetWriter` is written
to modify the markdown files where it has to copy some of the code fragments
the other segment handler collected before.

Segments in python start with the line

```python
# START SNIPPET run_py
``` 

and the end of the segment is

```python
# END SNIPPET
```

The `run_py` is the name of the snippet. The `SnippetReader` will copy the lines between
the start and end line into the memory and when `MdSnippetWriter` is executed it will
be available in a python dictionary.

Similarly, segments in the markdown files start with 

```
[//]: # (USE SNIPPET run.py/run__py)
```

and ends with a line that contains only three backticks. The keywords `USE SNIPPET` tell
Pyama to start a new segment and the `run.py/run_py` tells the segment handler
`MdSnippetWriter` that it has to replace the content of the segment as it is now
to the snippet that came from the file `run.py` and is named `run_py`. (Note that in the
sample above I had to replace `run_py` with `run__py` otherwise Pyama was recognizing
it as something it could process.)

## Command line options

```bash
usage: run.py [-h] [-l LEVEL] [-d] [-b] [-f LOGFILE]

optional arguments:
  -h, --help            show this help message and exit
  -l LEVEL, --level LEVEL
                        set the logging level explicitly DEBUG, INFO, WARNING,
                        ERROR or CRITICAL
  -d, --dry             do not write the changes back to the files
  -b, --backup          create .BAK for changed files
  -f LOGFILE, --logfile LOGFILE
                        create .BAK for changed files
```

(This is copied here with manual labor until we will have a handler that can run an external program
and capture the output as a snippet.)

## Precooked handlers

Pyama comes with an ever-expanding list of pre-cooked handlers. These are

* [snippet handler](./doc/snippet.md) can recognize code snippets in program source files
and can copy these into documentation files (especially into markdown files) 

* [javahandler](./doc/javahandler.md) can create constructors, setters, getters, `equals`
and `hashCode` methods as well as `toString` and nested builder class in Java classes.

* [licensehandler](./doc/licensehandler.md) can check that each file has a license text
at the start of it and inserts the license text if it was not there or updates the text
if it changed in a separate sample license file

## More documentation

If you have the segment handlers and can run python code and you are satisfied then
there is no point to read on. The application can be installed with minimal python
infrastructure knowledge and the `run.py` can easily be created without really
understanding python.

However, if you need something that is not available and you want to write segment handler(s)
then go on.

* [Architecture, structure of pyama](./doc/architecture.md)
* [Writing segment handlers](./doc/segmenthandlers.md)